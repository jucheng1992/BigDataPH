raw <- x
while (x > 1) {
x <- ifelse(x%%2==0,x/2,3*x+1)
n = n + 1
}
return(c(raw,n))
}
size<-100
ssteps=1:size
Estime<- system.time({
For(i=1:size){
ssteps[i]<- func(i)
}
})
Eptime<- system.time({
psteps <- foreach(x=1:size,.combine='rbind') %dopar% func(x)
stopCluster(cl)
})
## Return which number will take most iteration to get 1.
psteps[which.max(psteps[,2]),]
Eptime
size<-100
ssteps=1:size
Estime<- system.time({
For(i in 1:size){
ssteps[i]<- func(i)
}
})
ssteps[which.max(ssteps[,2]),]
Estime
system.time({
For(i in 1:size){
ssteps[i]<- func(i)
}
})
For(i in 1:size){
for(i in 1:size){
ssteps[i]<- func(i)
}
warnings()
ssteps[which.max(ssteps[,2]),]
func(5)
func(11)
ssteps<-vector()
system.time({
for(i in 1:size){
ssteps[i][]<- func(i)
}
})
ssteps[which.max(ssteps[,2]),]
size<-100
system.time({
for(i in 1:size){
ssteps[i][]<- func(i)
}
})
ssteps[i][]<- func(i)
system.time({
for(i in 1:size){
res<- func(i)
ssteps[i][1]<-res[1]
ssteps[i][2]<-res[2]
}
})
func(1)[1]
func(1)[2]
ssteps[which.max(ssteps[,2]),]
ssteps
ssteps[1][1]
ssteps[5][1]
ssteps[5][2]
func <- function(x) {
n = 1
raw <- x
while (x > 1) {
if(x%%2==0){
x/2
}else{
3*x+1
}
n=n+1
}
return(c(raw,n))
}
func(1)
func(66)
a<c(1,2,3,4,5)
a<c-(1,2,3,4,5)
a<-c(1,2,3,4,5)
which.max(a)
func <- function(x) {
n = 1
raw <- x
while (x > 1) {
x <- ifelse(x%%2==0,x/2,3*x+1)
n = n + 1
}
return(n)
}
size<-1000
Eptime<- system.time({
psteps <- foreach(x=1:size,.combine='rbind') %dopar% func(x)
stopCluster(cl)
})
})
Eptime<- system.time({
psteps <- foreach(x=1:size,.combine='rbind') %dopar% func(x)
stopCluster(cl)
})
View(psteps)
func <- function(x) {
n = 1
raw <- x
while (x > 1) {
x <- ifelse(x%%2==0,x/2,3*x+1)
n = n + 1
}
return(n)
}
size<-1000
Eptime<- system.time({
psteps <- foreach(x=1:size,.combine='rbind') %dopar% func(x)
stopCluster(cl)
})
func <- function(x) {
n = 1
raw <- x
while (x > 1) {
x <- ifelse(x%%2==0,x/2,3*x+1)
n = n + 1
}
return(c(raw,n))
}
size<-1000
Eptime<- system.time({
psteps <- foreach(x=1:size,.combine='rbind') %dopar% func(x)
stopCluster(cl)
})
size<-1000
Eptime<- system.time({
psteps <- foreach(x=1:size,.combine='rbind') %dopar% func(x) stopCluster(cl)
})
## Return which number will take most iteration to get 1.
psteps[which.max(psteps[,2]),]
Eptime<- system.time({
psteps <- foreach(x=1:size,.combine='rbind') %dopar% func(x) stopCluster(cl)
size<-1000
Eptime<- system.time({
psteps <- foreach(x=1:size,.combine='rbind') %dopar% func(x)
stopCluster(cl)
})
## Return which number will take most iteration to get 1.
psteps[which.max(psteps[,2]),]
func <- function(x) {
n = 1
raw <- x
while (x > 1) {
x <- ifelse(x%%2==0,x/2,3*x+1)
n = n + 1
}
return(c(raw,n))
}
func(88)
func <- function(x){
n = 1
raw <- x
while (x > 1) {
x <- ifelse(x%%2==0,x/2,3*x+1)
n = n + 1
}
return(c(raw,n))
}
```
```{r}
size<-1000
Eptime<- system.time({
psteps <- foreach(x=1:size,.combine='rbind') %dopar% func(x)
stopCluster(cl)
})
library(doParallel)
cl <- makeCluster(2)
registerDoParallel(cl)
func <- function(x){
n = 1
raw <- x
while (x > 1) {
x <- ifelse(x%%2==0,x/2,3*x+1)
n = n + 1
}
return(c(raw,n))
size<-1000
Eptime<- system.time({
psteps <- foreach(x=1:size,.combine='rbind') %dopar% func(x)
stopCluster(cl)
})
## Return which number will take most iteration to get 1.
psteps[which.max(psteps[,2]),]
-
}
size<-1000
Eptime<- system.time({
psteps <- foreach(x=1:size,.combine='rbind') %dopar% func(x)
stopCluster(cl)
})
## Return which number will take most iteration to get 1.
psteps[which.max(psteps[,2]),]
library(doParallel)
cl <- makeCluster(2)
registerDoParallel(cl)
func <- function(x){
n = 1
raw <- x
while (x > 1) {
x <- ifelse(x%%2==0,x/2,3*x+1)
n = n + 1
}
return(n)
}
size<-1000
Eptime<- system.time({
psteps <- foreach(x=1:size,.combine='rbind') %dopar% func(x)
stopCluster(cl)
})
## Return which number will take most iteration to get 1.
which.max(psteps)
## using bootstrap to find the variance of median of exponential
library(foreach)
library(doParallel)
data<- rexp(100,rate=3) #generate 100 exponential data
##set the number of bootstraping
B=1000
cl <- makeCluster(2)
registerDoParallel(cl)
ptime<-system.time({
medians <- foreach(1:B,.combine = c) %dopar% median(sample(data, 100, replace=TRUE))
})
vboot<-sum((medians - mean(medians))^2) / B
sqrt(vboot)
####sequential#####
stime<-system.time({
medians1<-rep(0,B)
for(i in 1:B){
medians1[i]=median(sample(data,100,replace=TRUE))
}
})
ptime
stime
## using bootstrap to find the variance of median of exponential
library(foreach)
library(doParallel)
data<- rexp(100,rate=3) #generate 100 exponential data
##set the number of bootstraping
B=100000
cl <- makeCluster(2)
registerDoParallel(cl)
ptime<-system.time({
medians <- foreach(1:B,.combine = c) %dopar% median(sample(data, 100, replace=TRUE))
})
## using bootstrap to find the variance of median of exponential
library(foreach)
library(doParallel)
data<- rexp(100,rate=3) #generate 100 exponential data
##set the number of bootstraping
B=10000
cl <- makeCluster(2)
registerDoParallel(cl)
ptime<-system.time({
medians <- foreach(1:B,.combine = c) %dopar% median(sample(data, 100, replace=TRUE))
})
vboot<-sum((medians - mean(medians))^2) / B
sqrt(vboot)
####sequential#####
stime<-system.time({
medians1<-rep(0,B)
for(i in 1:B){
medians1[i]=median(sample(data,100,replace=TRUE))
}
})
ptime
stime
## using bootstrap to find the variance of median of exponential
library(foreach)
library(doParallel)
data<- rexp(100,rate=3) #generate 100 exponential data
##set the number of bootstraping
B=10000
cl <- makeCluster(2)
registerDoParallel(cl)
ptime<-system.time({
medians <- foreach(1:B,.combine = c) %dopar% median(sample(data, 100, replace=TRUE))
})
vboot<-sum((medians - mean(medians))^2) / B
sqrt(vboot)
####sequential#####
stime<-system.time({
medians1<-rep(0,B)
for(i in 1:B){
medians1[i]=median(sample(data,100,replace=TRUE))
}
})
ptime
stime
library(doParallel)
library(randomForest)
prf.time<-system.time({
cl <- makeCluster(4)
registerDoParallel(cl)
## each cluster, we set 2500 trees
rf <- foreach(ntree=rep(2500, 4),
.combine=combine,
.packages='randomForest') %dopar%
randomForest(Species~., data=iris, ntree=ntree)
stopCluster(cl)
})
## directly use sequential programming getting 10000 trees
srf.time<-system.time(
randomForest(Species~., data=iris, ntree=10000)
)
prf.time
srf.time
library(doParallel)
x <- foreach(i=1:10) %do% sqrt(i)
x
stime<-system.time({
medians1<-rep(0,B)
for(i in 1:B){
medians1[i]=median(sample(data,100,replace=TRUE))
}
})
## iris dataset
x<- iris[which(iris[,5]!='setosa'),c(1,5)]
trials<- 100
# Parallel Computing
ptime<- system.time({
## icount count number of times that the iterator will fire.
r1<- foreach(icount(trials), .combine=cbind) %dopar% {
## Do sample from index 1 to 100. Sample 100 times with repalcement.
ind<- sample(100,100,replace=T)
## Here we use logistic model. We use glm function used sampled data
result1<- glm(x[ind,2]~x[ind,1],family=binomial(logit))
coefficients(result1)
}
r
})
library(doParallel)
#making cluster. Here we set the number of clusters equal to 2.
cl <- makeCluster(2)
registerDoParallel(cl)
## iris dataset
x<- iris[which(iris[,5]!='setosa'),c(1,5)]
trials<- 100
# Parallel Computing
ptime<- system.time({
## icount count number of times that the iterator will fire.
r1<- foreach(icount(trials), .combine=cbind) %dopar% {
## Do sample from index 1 to 100. Sample 100 times with repalcement.
ind<- sample(100,100,replace=T)
## Here we use logistic model. We use glm function used sampled data
result1<- glm(x[ind,2]~x[ind,1],family=binomial(logit))
coefficients(result1)
}
})
r1
head(r1)
View(`r1`)
r1[1]
r1[1][1]
r1[1][2]
r1[2]
r1[3]
r1[4]
r1$result.1
ssteps
Estime<- system.time({
ssteps <- foreach(x=1:size,.combine='rbind') %do% func(x)
})
ssteps[which.max(ssteps[,2]),]
Eptime
Estime
ssteps
size<-10000
Eptime<- system.time({
psteps <- foreach(x=1:size,.combine='rbind') %dopar% func(x)
stopCluster(cl)
})
psteps
ptime<- system.time({
## icount count number of times that the iterator will fire.
r1<- foreach(icount(trials), .combine=rbind) %dopar% {
## Do sample from index 1 to 100. Sample 100 times with repalcement.
ind<- sample(100,100,replace=T)
## Here we use logistic model. We use glm function used sampled data
result1<- glm(x[ind,2]~x[ind,1],family=binomial(logit))
coefficients(result1)
}
})
## Compared with Sequatial Computing
stime<- system.time({
r2<- foreach(icount(trials), .combine=rbind) %do% {
ind<- sample(100,100,replace=T)
result1<- glm(x[ind,2]~x[ind,1],family=binomial(logit))
coefficients(result1)
}
})
ptime<- system.time({
## icount count number of times that the iterator will fire.
r1<- foreach(icount(trials), .combine=cbind) %dopar% {
## Do sample from index 1 to 100. Sample 100 times with repalcement.
ind<- sample(100,100,replace=T)
## Here we use logistic model. We use glm function used sampled data
result1<- glm(x[ind,2]~x[ind,1],family=binomial(logit))
coefficients(result1)
}
})
## Compared with Sequatial Computing
stime<- system.time({
r2<- foreach(icount(trials), .combine=cbind) %do% {
ind<- sample(100,100,replace=T)
result1<- glm(x[ind,2]~x[ind,1],family=binomial(logit))
coefficients(result1)
}
})
ptime<- system.time({
## icount count number of times that the iterator will fire.
r1<- foreach(icount(trials), .combine=cbind) %dopar% {
## Do sample from index 1 to 100. Sample 100 times with repalcement.
ind<- sample(100,100,replace=T)
## Here we use logistic model. We use glm function used sampled data
result1<- glm(x[ind,2]~x[ind,1],family=binomial(logit))
coefficients(result1)
}
})
library(doParallel)
#making cluster. Here we set the number of clusters equal to 2.
cl <- makeCluster(2)
registerDoParallel(cl)
## iris dataset
x<- iris[which(iris[,5]!='setosa'),c(1,5)]
trials<- 100
# Parallel Computing
ptime<- system.time({
## icount count number of times that the iterator will fire.
r1<- foreach(icount(trials), .combine=cbind) %dopar% {
## Do sample from index 1 to 100. Sample 100 times with repalcement.
ind<- sample(100,100,replace=T)
## Here we use logistic model. We use glm function used sampled data
result1<- glm(x[ind,2]~x[ind,1],family=binomial(logit))
coefficients(result1)
}
})
## Compared with Sequatial Computing
stime<- system.time({
r2<- foreach(icount(trials), .combine=cbind) %do% {
ind<- sample(100,100,replace=T)
result1<- glm(x[ind,2]~x[ind,1],family=binomial(logit))
coefficients(result1)
}
})
ptime
stime
r1
install.packages('RhpcBLASctl')
require(RhpcBLASctl)
install.packages('RhpcBLASctl')require(RhpcBLASctl)blas_set_num_threads(4)set.seed(0)x <- matrix(rnorm(5000^2), 5000) system.time({      x <- crossprod(x)      U <- chol(x)       })
install.packages('RhpcBLASctl')
install.packages("RhpcBLASctl")
install.packages('RhpcBLASctl')
require(RhpcBLASctl)
blas_set_num_threads(4)
set.seed(0)
x <- matrix(rnorm(5000^2), 5000) system.time({
x <- matrix(rnorm(5000^2), 5000)
system.time({
x <- crossprod(x)
U <- chol(x)
})
install.packages('RhpcBLASctl')require(RhpcBLASctl)blas_set_num_threads(4)set.seed(0)x <- matrix(rnorm(5000^2), 5000) system.time({      x <- crossprod(x)      U <- chol(x)       })blas_set_num_threads(1)set.seed(0)x <- matrix(rnorm(5000^2), 5000) system.time({      x <- crossprod(x)      U <- chol(x)})
blas_set_num_threads(1)
set.seed(0)
x <- matrix(rnorm(5000^2), 5000)
system.time({
x <- crossprod(x)
U <- chol(x)
})
library(doParallel)
#making cluster. Here we set the number of clusters equal to 2.
cl <- makeCluster(2)
registerDoParallel(cl)
## iris dataset
x<- iris[which(iris[,5]!='setosa'),c(1,5)]
trials<- 1e5
# Parallel Computing
ptime<- system.time({
## icount count number of times that the iterator will fire.
r1<- foreach(icount(trials), .combine=cbind) %dopar% {
## Do sample from index 1 to 100. Sample 100 times with repalcement.
ind<- sample(100,100,replace=T)
## Here we use logistic model. We use glm function used sampled data
result1<- glm(x[ind,2]~x[ind,1],family=binomial(logit))
coefficients(result1)
}
})
## Compared with Sequatial Computing
stime<- system.time({
r2<- foreach(icount(trials), .combine=cbind) %do% {
ind<- sample(100,100,replace=T)
result1<- glm(x[ind,2]~x[ind,1],family=binomial(logit))
coefficients(result1)
}
})
ptime
stime
